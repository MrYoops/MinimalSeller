from fastapi import APIRouter, HTTPException, Depends, Query
from typing import List, Optional, Dict, Any
from datetime import datetime, timedelta
from bson import ObjectId
import aiohttp
import os
from io import BytesIO
import pandas as pd
from fastapi.responses import StreamingResponse

from backend.core.database import get_database
from auth_utils import get_current_user

router = APIRouter(prefix="/api/profit-analytics", tags=["profit-analytics"])


class OzonFinancialTransaction:
    """Финансовая транзакция из Ozon с полной детализацией"""
    
    @staticmethod
    def from_ozon_api(seller_id: str, ozon_data: dict) -> dict:
        """Преобразовать данные из Ozon API в нашу модель"""
        
        # Парсим услуги и расходы
        services = ozon_data.get("services", [])
        
        commission_base = 0.0
        logistics_delivery = 0.0
        logistics_last_mile = 0.0
        service_storage = 0.0
        service_acquiring = 0.0
        service_pvz = 0.0
        service_packaging = 0.0
        penalties = 0.0
        other_charges = 0.0
        
        # Маппинг типов услуг Ozon на наши категории
        for service in services:
            service_name = service.get("name", "")
            price = abs(service.get("price", 0.0))
            
            if "Commission" in service_name or "MarketplaceServiceItemFulfillment" in service_name:
                commission_base += price
            elif "DeliveryToCustomer" in service_name or "Delivery" in service_name:
                logistics_delivery += price
            elif "LastMile" in service_name or "DropoffPVZ" in service_name:
                logistics_last_mile += price
            elif "Storage" in service_name or "Storing" in service_name:
                service_storage += price
            elif "Acquiring" in service_name or "Payment" in service_name:
                service_acquiring += price
            elif "PVZ" in service_name or "PickupPoint" in service_name:
                service_pvz += price
            elif "Package" in service_name or "Packaging" in service_name:
                service_packaging += price
            elif "Penalty" in service_name or "Fine" in service_name:
                penalties += price
            else:
                other_charges += price
        
        # Обрабатываем товары
        items = []
        for item in ozon_data.get("items", []):
            items.append({
                "sku": item.get("sku", ""),
                "name": item.get("name", ""),
                "quantity": item.get("quantity", 1),
                "price": item.get("price", 0.0),
            })
        
        # Формируем нашу структуру
        transaction = {
            "seller_id": seller_id,
            "marketplace": "ozon",
            "transaction_id": str(ozon_data.get("operation_id", "")),
            "order_id": ozon_data.get("posting_number", ""),
            "posting_number": ozon_data.get("posting_number", ""),
            "operation_date": datetime.fromisoformat(ozon_data.get("operation_date", "").replace("Z", "+00:00")),
            "operation_type": ozon_data.get("operation_type", ""),
            "amount": ozon_data.get("amount", 0.0),
            "breakdown": {
                "commission": {
                    "base_commission": commission_base,
                    "bonus_commission": 0.0,
                    "total": commission_base
                },
                "logistics": {
                    "delivery_to_customer": logistics_delivery,
                    "last_mile": logistics_last_mile,
                    "returns": 0.0,
                    "total": logistics_delivery + logistics_last_mile
                },
                "services": {
                    "storage": service_storage,
                    "acquiring": service_acquiring,
                    "pvz_fee": service_pvz,
                    "packaging": service_packaging,
                    "total": service_storage + service_acquiring + service_pvz + service_packaging
                },
                "penalties": {"total": penalties},
                "other_charges": {"total": other_charges}
            },
            "items": items,
            "created_at": datetime.utcnow(),
            "updated_at": datetime.utcnow(),
            "data_source": "api",
            "raw_data": ozon_data
        }
        
        return transaction


async def get_ozon_api_credentials(seller_id: str):
    """Получить API ключи Ozon для продавца"""
    db = await get_database()
    
    # Ищем API ключи
    profile = await db.seller_profiles.find_one({"user_id": seller_id})
    
    if not profile or not profile.get("api_keys"):
        raise HTTPException(
            status_code=404,
            detail="Ozon API ключи не найдены. Добавьте их в настройках интеграций."
        )
    
    # Ищем ключ для Ozon
    ozon_key = None
    for key in profile.get("api_keys", []):
        if key.get("marketplace") == "ozon":
            ozon_key = key
            break
    
    if not ozon_key:
        raise HTTPException(
            status_code=404,
            detail="Ozon API ключ не найден. Добавьте его в настройках."
        )
    
    return {
        "client_id": ozon_key.get("client_id"),
        "api_key": ozon_key.get("api_key")
    }


async def fetch_ozon_transactions(
    client_id: str,
    api_key: str,
    date_from: datetime,
    date_to: datetime,
    operation_types: List[str] = None
) -> List[dict]:
    """Получить транзакции из Ozon API"""
    url = "https://api-seller.ozon.ru/v3/finance/transaction/list"
    headers = {
        "Client-Id": client_id,
        "Api-Key": api_key,
        "Content-Type": "application/json"
    }
    
    all_transactions = []
    page = 1
    
    if operation_types is None:
        operation_types = ["orders"]
    
    async with aiohttp.ClientSession() as session:
        while True:
            body = {
                "filter": {
                    "date": {
                        "from": date_from.isoformat(),
                        "to": date_to.isoformat()
                    },
                    "operation_type": operation_types,
                    "transaction_type": "all"
                },
                "page": page,
                "page_size": 1000
            }
            
            async with session.post(url, headers=headers, json=body) as resp:
                if resp.status != 200:
                    error_text = await resp.text()
                    raise HTTPException(
                        status_code=resp.status,
                        detail=f"Ошибка Ozon API: {error_text}"
                    )
                
                data = await resp.json()
                operations = data.get("result", {}).get("operations", [])
                
                if not operations:
                    break
                
                all_transactions.extend(operations)
                page += 1
                
                if page > 100:
                    break
    
    return all_transactions


@router.post("/sync-ozon-data")
async def sync_ozon_data(
    date_from: str = Query(..., description="Дата начала периода (YYYY-MM-DD)"),
    date_to: str = Query(..., description="Дата конца периода (YYYY-MM-DD)"),
    current_user: dict = Depends(get_current_user)
):
    """Синхронизировать данные из Ozon API"""
    seller_id = str(current_user["_id"])
    
    try:
        period_start = datetime.fromisoformat(f"{date_from}T00:00:00")
        period_end = datetime.fromisoformat(f"{date_to}T23:59:59")
    except ValueError:
        raise HTTPException(status_code=400, detail="Неверный формат даты")
    
    credentials = await get_ozon_api_credentials(seller_id)
    
    try:
        ozon_transactions = await fetch_ozon_transactions(
            credentials["client_id"],
            credentials["api_key"],
            period_start,
            period_end,
            operation_types=["orders"]
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Ошибка Ozon API: {str(e)}")
    
    db = await get_database()
    saved_count = 0
    updated_count = 0
    
    for ozon_txn in ozon_transactions:
        transaction = OzonFinancialTransaction.from_ozon_api(seller_id, ozon_txn)
        
        result = await db.marketplace_transactions.update_one(
            {
                "seller_id": seller_id,
                "marketplace": "ozon",
                "transaction_id": transaction["transaction_id"]
            },
            {"$set": transaction},
            upsert=True
        )
        
        if result.upserted_id:
            saved_count += 1
        else:
            updated_count += 1
    
    return {
        "status": "success",
        "message": "Синхронизация завершена",
        "period": {"from": date_from, "to": date_to},
        "statistics": {
            "total_transactions": len(ozon_transactions),
            "saved": saved_count,
            "updated": updated_count
        }
    }


@router.get("/profit-report")
async def get_profit_report(
    date_from: str = Query(..., description="Дата начала периода"),
    date_to: str = Query(..., description="Дата конца периода"),
    marketplace: Optional[str] = Query(None),
    current_user: dict = Depends(get_current_user)
):
    """Получить отчет о чистой прибыли"""
    seller_id = str(current_user["_id"])
    
    try:
        period_start = datetime.fromisoformat(f"{date_from}T00:00:00")
        period_end = datetime.fromisoformat(f"{date_to}T23:59:59")
    except ValueError:
        raise HTTPException(status_code=400, detail="Неверный формат даты")
    
    db = await get_database()
    
    match_filter = {
        "seller_id": seller_id,
        "operation_date": {"$gte": period_start, "$lte": period_end}
    }
    if marketplace:
        match_filter["marketplace"] = marketplace
    
    pipeline = [
        {"$match": match_filter},
        {"$group": {
            "_id": None,
            "total_amount": {"$sum": "$amount"},
            "transaction_count": {"$sum": 1},
            "commission_base": {"$sum": "$breakdown.commission.base_commission"},
            "commission_bonus": {"$sum": "$breakdown.commission.bonus_commission"},
            "logistics_delivery": {"$sum": "$breakdown.logistics.delivery_to_customer"},
            "logistics_last_mile": {"$sum": "$breakdown.logistics.last_mile"},
            "logistics_returns": {"$sum": "$breakdown.logistics.returns"},
            "service_storage": {"$sum": "$breakdown.services.storage"},
            "service_acquiring": {"$sum": "$breakdown.services.acquiring"},
            "service_pvz": {"$sum": "$breakdown.services.pvz_fee"},
            "service_packaging": {"$sum": "$breakdown.services.packaging"},
            "penalties": {"$sum": "$breakdown.penalties.total"},
            "other_charges": {"$sum": "$breakdown.other_charges.total"},
            "all_items": {"$push": "$items"}
        }}
    ]
    
    result = await db.marketplace_transactions.aggregate(pipeline).to_list(1)
    
    if not result or not result[0]:
        return {
            "period": {"from": date_from, "to": date_to},
            "marketplace": marketplace or "all",
            "revenue": {"gross_sales": 0, "net_sales": 0},
            "cogs": {"total": 0, "percentage": 0},
            "expenses": {"total_expenses": 0},
            "profit": {"net_profit": 0, "net_margin_pct": 0},
            "message": "Нет данных за указанный период"
        }
    
    data = result[0]
    
    # Рассчитываем себестоимость (COGS)
    all_items = data.get("all_items", [])
    total_cogs = 0.0
    for items_list in all_items:
        if items_list:
            for item in items_list:
                total_cogs += item.get("total_cost", 0.0)
    
    gross_sales = data.get("total_amount", 0.0)
    
    # Расходы
    commission_total = data.get("commission_base", 0.0) + data.get("commission_bonus", 0.0)
    logistics_total = (
        data.get("logistics_delivery", 0.0) + 
        data.get("logistics_last_mile", 0.0) + 
        data.get("logistics_returns", 0.0)
    )
    services_total = (
        data.get("service_storage", 0.0) +
        data.get("service_acquiring", 0.0) +
        data.get("service_pvz", 0.0) +
        data.get("service_packaging", 0.0)
    )
    penalties_total = data.get("penalties", 0.0)
    other_total = data.get("other_charges", 0.0)
    
    total_expenses = (
        commission_total +
        logistics_total +
        services_total +
        penalties_total +
        other_total
    )
    
    # Валовая прибыль = Выручка - Себестоимость
    gross_profit = gross_sales - total_cogs
    gross_margin_pct = (gross_profit / gross_sales * 100) if gross_sales > 0 else 0.0
    
    # Операционная прибыль = Валовая прибыль - Расходы
    operating_profit = gross_profit - total_expenses
    operating_margin_pct = (operating_profit / gross_sales * 100) if gross_sales > 0 else 0.0
    
    # Чистая прибыль = Операционная прибыль
    net_profit = operating_profit
    net_margin_pct = operating_margin_pct
    
    report = {
        "period": {"from": date_from, "to": date_to},
        "marketplace": marketplace or "all",
        "statistics": {"total_transactions": data.get("transaction_count", 0)},
        "revenue": {
            "gross_sales": round(gross_sales, 2),
            "returns": 0.0,
            "net_sales": round(gross_sales, 2)
        },
        "cogs": {
            "total": round(total_cogs, 2),
            "percentage": round((total_cogs / gross_sales * 100) if gross_sales > 0 else 0.0, 2)
        },
        "expenses": {
            "commissions": {
                "marketplace_base": round(data.get("commission_base", 0.0), 2),
                "bonus_commission": round(data.get("commission_bonus", 0.0), 2),
                "total": round(commission_total, 2)
            },
            "logistics": {
                "delivery_to_customer": round(data.get("logistics_delivery", 0.0), 2),
                "last_mile": round(data.get("logistics_last_mile", 0.0), 2),
                "returns": round(data.get("logistics_returns", 0.0), 2),
                "total": round(logistics_total, 2)
            },
            "services": {
                "storage": round(data.get("service_storage", 0.0), 2),
                "acquiring": round(data.get("service_acquiring", 0.0), 2),
                "pvz_fees": round(data.get("service_pvz", 0.0), 2),
                "packaging": round(data.get("service_packaging", 0.0), 2),
                "total": round(services_total, 2)
            },
            "penalties": {"total": round(penalties_total, 2)},
            "other_expenses": {"total": round(other_total, 2)},
            "total_expenses": round(total_expenses, 2)
        },
        "profit": {
            "gross_profit": round(gross_profit, 2),
            "gross_margin_pct": round(gross_margin_pct, 2),
            "operating_profit": round(operating_profit, 2),
            "operating_margin_pct": round(operating_margin_pct, 2),
            "net_profit": round(net_profit, 2),
            "net_margin_pct": round(net_margin_pct, 2)
        }
    }
    
    return report


@router.get("/export-profit-report")
async def export_profit_report_to_excel(
    date_from: str = Query(...),
    date_to: str = Query(...),
    marketplace: Optional[str] = Query(None),
    current_user: dict = Depends(get_current_user)
):
    """Экспортировать отчет в Excel"""
    report = await get_profit_report(date_from, date_to, marketplace, current_user)
    
    output = BytesIO()
    
    with pd.ExcelWriter(output, engine='openpyxl') as writer:
        summary_data = {
            "Показатель": [
                "Период", "Маркетплейс", "",
                "ВЫРУЧКА",
                "Валовая выручка", "Возвраты", "Чистая выручка", "",
                "СЕБЕСТОИМОСТЬ", "Закупочная цена товаров", "",
                "ВАЛОВАЯ ПРИБЫЛЬ", "Валовая маржа (%)", "",
                "РАСХОДЫ",
                "Комиссии маркетплейса", "  - Базовая", "  - От бонусов",
                "Логистика", "  - Доставка", "  - Последняя миля", "  - Возвраты",
                "Услуги", "  - Хранение", "  - Эквайринг", "  - ПВЗ", "  - Упаковка",
                "Штрафы", "Прочие", "",
                "ИТОГО РАСХОДОВ", "",
                "ОПЕРАЦИОННАЯ ПРИБЫЛЬ", "Операционная маржа (%)", "",
                "ЧИСТАЯ ПРИБЫЛЬ", "Чистая маржа (%)"
            ],
            "Значение": [
                f"{report['period']['from']} - {report['period']['to']}",
                report['marketplace'], "",
                "",
                report['revenue']['gross_sales'],
                report['revenue']['returns'],
                report['revenue']['net_sales'], "",
                "",
                report['cogs']['total'], "",
                report['profit']['gross_profit'],
                report['profit']['gross_margin_pct'], "",
                "",
                "",
                report['expenses']['commissions']['marketplace_base'],
                report['expenses']['commissions']['bonus_commission'],
                "",
                report['expenses']['logistics']['delivery_to_customer'],
                report['expenses']['logistics']['last_mile'],
                report['expenses']['logistics']['returns'],
                "",
                report['expenses']['services']['storage'],
                report['expenses']['services']['acquiring'],
                report['expenses']['services']['pvz_fees'],
                report['expenses']['services']['packaging'],
                report['expenses']['penalties']['total'],
                report['expenses']['other_expenses']['total'], "",
                report['expenses']['total_expenses'], "",
                report['profit']['operating_profit'],
                report['profit']['operating_margin_pct'], "",
                report['profit']['net_profit'],
                report['profit']['net_margin_pct']
            ]
        }
        
        df = pd.DataFrame(summary_data)
        df.to_excel(writer, sheet_name='Сводка', index=False)
    
    output.seek(0)
    filename = f"profit_report_{date_from}_{date_to}.xlsx"
    
    return StreamingResponse(
        output,
        media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        headers={"Content-Disposition": f"attachment; filename={filename}"}
    )


@router.get("/transactions")
async def get_transactions(
    date_from: str = Query(...),
    date_to: str = Query(...),
    marketplace: Optional[str] = Query(None),
    limit: int = Query(100, ge=1, le=1000),
    offset: int = Query(0, ge=0),
    current_user: dict = Depends(get_current_user)
):
    """Получить список транзакций"""
    seller_id = str(current_user["_id"])
    
    try:
        period_start = datetime.fromisoformat(f"{date_from}T00:00:00")
        period_end = datetime.fromisoformat(f"{date_to}T23:59:59")
    except ValueError:
        raise HTTPException(status_code=400, detail="Неверный формат даты")
    
    db = await get_database()
    
    match_filter = {
        "seller_id": seller_id,
        "operation_date": {"$gte": period_start, "$lte": period_end}
    }
    if marketplace:
        match_filter["marketplace"] = marketplace
    
    transactions = await db.marketplace_transactions.find(
        match_filter
    ).sort("operation_date", -1).skip(offset).limit(limit).to_list(limit)
    
    total_count = await db.marketplace_transactions.count_documents(match_filter)
    
    for txn in transactions:
        txn["_id"] = str(txn["_id"])
        txn["operation_date"] = txn["operation_date"].isoformat()
        txn["created_at"] = txn["created_at"].isoformat()
        txn["updated_at"] = txn["updated_at"].isoformat()
    
    return {
        "transactions": transactions,
        "total_count": total_count,
        "limit": limit,
        "offset": offset
    }
